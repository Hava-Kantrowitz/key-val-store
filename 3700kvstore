#!/usr/bin/env python3

import math, sys, socket, select, datetime, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0
leader = " "
term = 0
state = "follower"
alreadyVoted = 0
received = 0
timeout_num = random.randrange(150, 300, 1)
in_election = False

log = []
values = {} 

def make_fail(msg):
    return json.dumps({"src": msg["dst"], "dst": msg["src"], "leader": msg["leader"], "type": "fail", "MID": msg["MID"]})

def make_ok(msg, val): 
    global leader
    return json.dumps({"src": my_id, "dst": msg["src"], "leader": leader, "type": "ok", "MID": msg["MID"], "value": val})

def make_redirect(msg):
    global leader 
    if leader == " ":
        lead = "FFFF"
        #print("I HAVE NO HECKIN CLUE WHO THE LEADER IS") 
    else:
        lead = leader
    return json.dumps({"src": my_id, "dst": msg["src"], "leader": lead, "type": "redirect", "MID": msg["MID"]})

def send_ballot():
    if len(log) == 0:
        last_log_term = -1
    else:
        last_log_term = log[-1]
 
    for val in replica_ids:
        sock.send(json.dumps({"src": my_id, "dst": val, "leader": "FFFF", "type": "ballot", "log_term": last_log_term, "log_len": len(log) - 1, "cur_term": term}).encode("ascii"))

def start_election():
    global term, state, alreadyVoted, received
    #when thing timesout go here
    in_election = True
    term += 1
    state = "candidate"
    alreadyVoted = 1
    received = 1
    send_ballot()

def recv_ballot(msg):
    global alreadyVoted
    #if already voted in current term ignore
    if alreadyVoted == 0: 
        index_ballot = msg["log_len"]
        index_voter = len(log) - 1
        term_ballot = msg["log_term"]
        term_voter = -1 if len(log) == 0 else log[-1]
        cur_term_ballot = msg["cur_term"]
        if term_ballot >= term_voter: 
            if index_ballot >= index_ballot:
                if (not in_election) or (in_election and cur_term_ballot > term):
                    sock.send(json.dumps({"src": my_id, "dst": msg["src"], "leader": "FFFF", "type": "vote"}).encode("ascii"))
                    alreadyVoted = 1

def recv_vote():
    global received
    received += 1
    if (math.floor(len(replica_ids) / 2) + 1) <= received: 
        end_election("win")  

def end_election(result):
    global in_election, leader, term, alreadyVoted
    in_election = False
    if result == "win":
        leader = my_id  
        for val in replica_ids:
            sock.send(json.dumps({"src": my_id, "dst": val, "leader": my_id, "type": "heartbeat", "term": term}).encode("ascii"))
    else: 
        #result is lose
        term = result["term"]
        leader = result["leader"]
        alreadyVoted = 0

while True:
    ready = select.select([sock], [], [], 0.1)[0]

    if sock in ready:
        msg_raw = sock.recv(32768).decode("ascii")

        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)

        #if msg["leader"] == leader:
        #    last = time.time()

        if msg['type'] == "ballot":
            recv_ballot(msg)

        if msg['type'] == "vote":
            recv_vote()

        if msg['type'] == "heartbeat":
            msecs = datetime.datetime.now().timestamp() * 1000
            last = msecs 
            end_election(msg)

        if msg['type'] == "put":
            if leader == my_id:
                log.append(term)
                values[msg['key']] = msg['value']
                if msg['key'] in values.keys():
                    sock.send(make_ok(msg, "OK").encode("ascii"))
                else: 
                    sock.send(make_fail(msg).encode("ascii"))
            else: 
                sock.send(make_redirect(msg).encode("ascii"))

        if msg['type'] == "get":
            if msg['key'] in values.keys():
                sock.send(make_ok(msg, values[msg['key']]).encode("ascii"))
            else: 
                sock.send(make_fail(msg).encode("ascii"))

        # Handle noop messages. This may be removed from your final implementation
        elif msg['type'] == 'noop':
            print('%s received a NOOP from %s' % (msg['dst'], msg['src']))

    msecs = datetime.datetime.now().timestamp() * 1000
    #print("MSECS {0}, LAST {1}, MSECS-LAST {2}, TIMEOUT {3}".format(msecs, last, msecs-last, timeout_num))
    if msecs - last > timeout_num:
        #timeout happened call doelection
        start_election()
        last = msecs

    if msecs - last > 100:
        if leader == my_id: 
            for val in replica_ids: 
                sock.send(json.dumps({"src": my_id, "dst": val, "leader": my_id, "type": "heartbeat", "term": term}).encode("ascii"))
            last = msecs 
